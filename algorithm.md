## 动态规划
### 确认是动态规划问题
- 动态规划问题的一般形式就是求最值, 比如说让你求最长递增子序列呀，最小编辑距离
- 存在重叠子问题
- 具备最优子结构

### 解法
- 明确状态
- 明确选择
- 确定dp数组/函数的定义
- 确定base case
- 找出状态转移方程

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

- 不同的状态转移方程有不同的解法
- 写出动态规划之后或许还可以降维
  * 如果计算状态 `dp[i][j]` 需要的都是 `dp[i][j]` 相邻的状态，那么就可以使用空间压缩技巧
  * 可画出推算的流程图进行分析，方便存储一些会覆盖的变量
- 或许可以转换解题思路，从而使用二分法优化O(n^2) -> O(N*logN)

### 子序列解题模板
- 一维的dp数组
  * 在子数组`array[0..i]`中，以`array[i]`结尾的目标子序列（最长递增子序列）的长度是`dp[i]`
- 二维的dp数组
  * 涉及两个字符串和数组时
    + 在子数组`arr1[0..i]`和子数组`arr2[0..j]`中，我们要求的子序列（最长公共子序列）长度为`dp[i][j]`
  * 只涉及一个字符串和数组时
    + 在子数组`array[i..j]`中，我们要求的子序列（最长回文子序列）的长度为`dp[i][j]`。
